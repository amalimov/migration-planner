// Package v1alpha1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package v1alpha1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	externalRef0 "github.com/kubev2v/migration-planner/api/v1alpha1"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "../openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
